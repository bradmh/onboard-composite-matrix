<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crew Matrix Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.8em;
            font-weight: 300;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.95;
            font-size: 1.2em;
        }
        
        .content {
            padding: 40px;
        }
        
        .instructions {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border-left: 5px solid #2196f3;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
        }
        
        .instructions h3 {
            color: #1976d2;
            margin-bottom: 15px;
        }
        
        .file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .file-card {
            background: #f8f9fa;
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .file-card:hover {
            border-color: #4299e1;
            background: #edf2f7;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.15);
        }
        
        .file-card.loaded {
            border-color: #48bb78;
            background: #f0fff4;
            border-style: solid;
        }
        
        .file-card h4 {
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .file-card p {
            color: #718096;
            font-size: 0.9em;
            margin-bottom: 12px;
            line-height: 1.5;
        }
        
        .file-card input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .status-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .status-badge.pending {
            background: #fed7d7;
            color: #c53030;
        }
        
        .status-badge.success {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-size: 0.85em;
            color: #4a5568;
        }
        
        .controls {
            background: #f7fafc;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
        }
        
        .controls h3 {
            color: #2d3748;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            color: #4a5568;
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .input-group input {
            width: 100%;
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.2s;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #4299e1;
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
        }
        
        .btn:disabled {
            background: #cbd5e0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress-section {
            background: #f7fafc;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #38a169);
            width: 0%;
            transition: width 0.4s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .results-box {
            background: #f0fff4;
            border: 2px solid #9ae6b4;
            border-radius: 12px;
            padding: 30px;
            margin: 25px 0;
        }
        
        .results-box h3 {
            color: #22543d;
            margin-bottom: 15px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #2b6cb0;
        }
        
        .stat-label {
            color: #718096;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .alert-warning {
            background: #feebc8;
            color: #7c2d12;
            border-left: 4px solid #dd6b20;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üö¢ Project Crew Matrix Generator</h1>
        </div>
        
        <div class="content">
            <div class="instructions">
                <h3>üìã How This Works</h3>
                <p><strong>Export three files from onboard tracker:</strong></p>
                <ul style="margin: 15px 0 15px 30px; line-height: 1.8;">
                    <li><strong>HR Export</strong> - Personal data file for all personnel
						<p>No filtering needed - export the default template</p></li>
                    <li><strong>All Certification Report</strong> - Comprehensive certification data with issue and expiry dates
						<p>Filter based on the project number</p></li>
                    <li><strong>Certificate Matrix V2</strong> - Core template for the composite matrix
						<p>Filter based on the project number and the mobilisation date (if required ie crew change matrix)</p>
						<p>For projects with client specific matrix requirements, select client under "Add Certification Requirements for Client"</p></li>
                </ul>
                <p style="margin-top: 15px;"><strong>The tool will create a sorted matrix:</strong> Travel Documents ‚Üí Medical ‚Üí Survival ‚Üí Other certs (alphabetically)</p>
            </div>
            
            <div class="file-grid">
                <div class="file-card" id="hrCard">
                    <span class="status-badge pending" id="hrBadge">Required</span>
                    <h4>1Ô∏è‚É£ HR Export</h4>
                    <input type="file" id="hrFile" accept=".xlsx,.xls" />
                    <div class="file-info" id="hrInfo" style="display:none;"></div>
                </div>
                
                <div class="file-card" id="allCertCard">
                    <span class="status-badge pending" id="allCertBadge">Required</span>
                    <h4>2Ô∏è‚É£ All Cerification Report</h4>
                    <input type="file" id="allCertFile" accept=".xlsx,.xls" />
                    <div class="file-info" id="allCertInfo" style="display:none;"></div>
                </div>
                
                <div class="file-card" id="matrixCard">
                    <span class="status-badge pending" id="matrixBadge">Required</span>
                    <h4>3Ô∏è‚É£ Certificate Matrix v2</h4>
                    <input type="file" id="matrixFile" accept=".xlsx,.xls" />
                    <div class="file-info" id="matrixInfo" style="display:none;"></div>
                </div>
            </div>
            
            <div class="controls">
                <h3>‚öôÔ∏è Configure Your Matrix</h3>
				<p>Optional - Formatting is limited, so this can also be added in Excel afterwards</p></br>
                <div class="input-group">
                    <div>
                        <label for="projectName">Project Number/Name</label>
                        <input type="text" id="projectName" placeholder="e.g., 25001 - PTTEP" />
                    </div>
                    <div>
                        <label for="projectYear">Project Year</label>
                        <input type="text" id="projectYear" placeholder="2025" value="2025" />
                    </div>
                    <div>
                        <label for="projectDescription">Project Description</label>
                        <input type="text" id="projectDescription" placeholder="e.g., PTTEP IRM" />
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" id="generateBtn" onclick="generateMatrix()" disabled>
                        üî® Generate Crew Matrix
                    </button>
                </div>
            </div>
            
            <div class="progress-section" id="progressSection" style="display:none;">
                <h3>Processing...</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <p id="progressText" style="color: #4a5568; margin-top: 10px;">Initializing...</p>
            </div>
            
            <div id="results"></div>
        </div>
    </div>

    <script>
        let hrData = null;
        let allCertData = null;
        let matrixData = null;
        
        document.getElementById('hrFile').onchange = (e) => loadFile(e.target.files[0], 'hr');
        document.getElementById('allCertFile').onchange = (e) => loadFile(e.target.files[0], 'allCert');
        document.getElementById('matrixFile').onchange = (e) => loadFile(e.target.files[0], 'matrix');
        
        function loadFile(file, type) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const workbook = XLSX.read(e.target.result, {type: 'binary'});
                    const sheetName = workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    const data = XLSX.utils.sheet_to_json(sheet, {header: 1, defval: ""});
                    
                    switch(type) {
                        case 'hr':
                            hrData = data;
                            updateFileStatus('hr', data.length);
                            break;
                        case 'allCert':
                            allCertData = data;
                            updateFileStatus('allCert', data.length);
                            break;
                        case 'matrix':
                            matrixData = data;
                            updateFileStatus('matrix', data.length);
                            break;
                    }
                    
                    checkAllFilesLoaded();
                } catch (error) {
                    showError(`Error loading ${type} file: ${error.message}`);
                }
            };
            reader.readAsBinaryString(file);
        }
        
        function updateFileStatus(type, rows) {
            const cardMap = {hr: 'hrCard', allCert: 'allCertCard', matrix: 'matrixCard'};
            const badgeMap = {hr: 'hrBadge', allCert: 'allCertBadge', matrix: 'matrixBadge'};
            const infoMap = {hr: 'hrInfo', allCert: 'allCertInfo', matrix: 'matrixInfo'};
            
            const card = document.getElementById(cardMap[type]);
            const badge = document.getElementById(badgeMap[type]);
            const info = document.getElementById(infoMap[type]);
            
            card.classList.add('loaded');
            badge.textContent = '‚úì Loaded';
            badge.classList.remove('pending');
            badge.classList.add('success');
            
            info.style.display = 'block';
            info.textContent = `‚úì ${rows} rows loaded successfully`;
        }
        
        function checkAllFilesLoaded() {
            const generateBtn = document.getElementById('generateBtn');
            
            if (hrData && allCertData && matrixData) {
                generateBtn.disabled = false;
            }
        }
        
        function showError(message) {
            const results = document.getElementById('results');
            results.innerHTML = `<div class="alert-warning">‚ö†Ô∏è ${message}</div>`;
        }
        
        function updateProgress(percentage, text) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressFill').textContent = percentage + '%';
            document.getElementById('progressText').textContent = text;
        }
        
        function generateMatrix() {
            const progressSection = document.getElementById('progressSection');
            const results = document.getElementById('results');
            
            progressSection.style.display = 'block';
            results.innerHTML = '';
            
            updateProgress(10, 'Processing HR data...');
            
            setTimeout(() => {
                try {
                    const hrPersonnel = processHRData();
                    
                    updateProgress(30, 'Processing certifications...');
                    const certsByPerson = processCertifications();
                    
                    updateProgress(50, 'Analyzing matrix structure...');
                    const matrixStructure = analyzeMatrixStructure();
                    
                    updateProgress(70, 'Matching and merging data...');
                    const finalMatrix = buildFinalMatrix(hrPersonnel, certsByPerson, matrixStructure);
                    
                    updateProgress(85, 'Creating Excel file...');
                    const workbook = createExcelFile(finalMatrix);
                    
                    updateProgress(100, 'Complete!');
                    
                    const projectName = document.getElementById('projectName').value || 'Project';
                    const fileName = `${projectName}_CrewMatrix_${new Date().toISOString().split('T')[0]}.xlsx`;
                    
                    const wbout = XLSX.write(workbook, {bookType:'xlsx', type:'binary'});
                    const blob = new Blob([s2ab(wbout)], {type:"application/octet-stream"});
                    const url = URL.createObjectURL(blob);
                    
                    results.innerHTML = `
                        <div class="results-box">
                            <h3>‚úÖ Crew Matrix Generated Successfully!</h3>
                            <div class="stats-grid">
                                <div class="stat-card">
                                    <div class="stat-value">${finalMatrix.personnel.length}</div>
                                    <div class="stat-label">Personnel</div>
                                </div>
                                <div class="stat-card">
                                    <div class="stat-value">${finalMatrix.certColumns.length}</div>
                                    <div class="stat-label">Certifications</div>
                                </div>
                            </div>
                            <a href="${url}" download="${fileName}" class="btn btn-primary" style="margin-top: 20px; text-decoration: none;">
                                üì• Download ${fileName}
                            </a>
                        </div>
                    `;
                    
                    setTimeout(() => progressSection.style.display = 'none', 2000);
                    
                } catch (error) {
                    console.error('Full error:', error);
                    updateProgress(0, 'Error occurred');
                    showError(`Error generating matrix: ${error.message}`);
                    progressSection.style.display = 'none';
                }
            }, 500);
        }
        
        function processHRData() {
            const personnel = {};
            const headers = hrData[1];
            
            const cols = {
                firstName: headers.indexOf('First Name'),
                middleName: headers.indexOf('Middle Name'),
                surname: headers.indexOf('Surname'),
                nationality: headers.indexOf('Nationality'),
                dob: headers.indexOf('Date Of Birth'),
                gender: headers.indexOf('Gender'),
                workEmail: headers.indexOf('Work Email'),
                workMobile: headers.indexOf('Work Mobile'),
                occupation: headers.indexOf('Occupation'),
                homeAirport: headers.indexOf('Home Airport')
            };
            
            for (let i = 2; i < hrData.length; i++) {
                const row = hrData[i];
                if (!row[cols.firstName] || !row[cols.surname]) continue;
                
                const fullName = `${row[cols.firstName]} ${row[cols.middleName] || ''} ${row[cols.surname]}`.replace(/\s+/g, ' ').trim();
                
                personnel[fullName] = {
                    firstName: row[cols.firstName] || '',
                    middleName: row[cols.middleName] || '',
                    surname: row[cols.surname] || '',
                    fullName: fullName,
                    nationality: row[cols.nationality] || '',
                    dob: row[cols.dob] || '',
                    age: row[cols.dob] ? calculateAge(row[cols.dob]) : '',
                    gender: row[cols.gender] || '',
                    workEmail: row[cols.workEmail] || '',
                    workMobile: row[cols.workMobile] || '',
                    occupation: row[cols.occupation] || '',
                    homeAirport: row[cols.homeAirport] || ''
                };
            }
            
            return personnel;
        }
        
        function processCertifications() {
            const certsByPerson = {};
            
            for (let i = 1; i < allCertData.length; i++) {
                const row = allCertData[i];
                const firstName = row[2];
                const middleName = row[3];
                const surname = row[4];
                
                if (!firstName || !surname) continue;
                
                const fullName = `${firstName} ${middleName || ''} ${surname}`.replace(/\s+/g, ' ').trim();
                
                if (!certsByPerson[fullName]) {
                    certsByPerson[fullName] = [];
                }
                
                const cert = row[25];
                const category = row[26];
                
                if (cert && category) {
                    certsByPerson[fullName].push({
                        type: cert,
                        category: category,
                        description: row[28] || '',
                        reference: row[29] || '',
                        validFrom: row[35] || '',
                        validTo: row[36] || '',
                        isValid: row[33] || false,
                        expiryStatus: row[34] || ''
                    });
                }
            }
            
            return certsByPerson;
        }
        
        function analyzeMatrixStructure() {
            const headers = matrixData[5];
            const basicInfoCols = 11;
            
            const certColumnsRaw = [];
            const categoryRow = matrixData[1];
            const certNameRow = matrixData[2];
            
            for (let i = basicInfoCols; i < headers.length; i++) {
                const certName = certNameRow[i] || headers[i] || '';
                const category = categoryRow[i] || '';
                
                if (certName.trim() !== '') {
                    certColumnsRaw.push({
                        index: i,
                        name: certName.trim(),
                        category: category.trim()
                    });
                }
            }
            
            const certColumnsUnique = [];
            const seenCerts = new Map();
            
            certColumnsRaw.forEach(cert => {
                const certKey = cert.name.toLowerCase().trim();
                if (certKey && !seenCerts.has(certKey)) {
                    seenCerts.set(certKey, cert);
                    certColumnsUnique.push(cert);
                }
            });
            
            const personnel = [];
            for (let i = 6; i < matrixData.length; i++) {
                const row = matrixData[i];
                const personName = (row[1] || '').toString().trim();
                
                if (!personName || 
                    personName.toLowerCase().includes('legend') ||
                    personName.toLowerCase().includes('certificate is') ||
                    personName.toLowerCase().includes('warning') ||
                    personName.toLowerCase().includes('expired')) {
                    break;
                }
                
                if (personName.length > 0) {
                    personnel.push({
                        name: personName,
                        occupation: row[5] || '',
                        team: row[4] || '',
                        email: row[3] || ''
                    });
                }
            }
            
            return {
                certColumns: certColumnsUnique,
                personnel
            };
        }
        
        function buildFinalMatrix(hrPersonnel, certsByPerson, matrixStructure) {
            const finalPersonnel = [];
            let counter = 1;
            
            matrixStructure.personnel.forEach(matrixPerson => {
                const hrMatch = findPersonMatch(matrixPerson.name, hrPersonnel);
                let certs = certsByPerson[matrixPerson.name] || [];
                if (!certs.length && hrMatch) {
                    certs = certsByPerson[hrMatch.fullName] || [];
                }
                
                const personData = {
                    no: counter++,
                    name: matrixPerson.name,
                    occupation: matrixPerson.occupation || hrMatch?.occupation || '',
                    team: matrixPerson.team || '',
                    email: matrixPerson.email || hrMatch?.workEmail || '',
                    nationality: hrMatch?.nationality || '',
                    dob: hrMatch?.dob || '',
                    age: hrMatch?.age || '',
                    gender: hrMatch?.gender || '',
                    workMobile: hrMatch?.workMobile || '',
                    homeAirport: hrMatch?.homeAirport || '',
                    certifications: {},
                    certificationDetails: {}
                };
                
                matrixStructure.certColumns.forEach(certCol => {
                    const matchingCert = certs.find(c => 
                        c.type.toLowerCase().includes(certCol.name.toLowerCase()) ||
                        certCol.name.toLowerCase().includes(c.type.toLowerCase())
                    );
                    
                    if (matchingCert) {
                        personData.certificationDetails[certCol.name] = {
                            ...matchingCert,
                            certName: certCol.name
                        };
                        personData.certifications[certCol.name] = matchingCert;
                    }
                });
                
                finalPersonnel.push(personData);
            });
            
            const certColumnsWithRealCategories = matrixStructure.certColumns.map(cert => {
                let actualCategory = cert.category;
                
                for (const person of finalPersonnel) {
                    const certDetail = person.certificationDetails[cert.name];
                    if (certDetail && certDetail.category) {
                        actualCategory = certDetail.category;
                        break;
                    }
                }
                
                return {...cert, category: actualCategory};
            });
            
            const sortedCertColumns = sortCertsByCategory(certColumnsWithRealCategories);
            
            return {
                personnel: finalPersonnel,
                certColumns: sortedCertColumns
            };
        }
        
        function sortCertsByCategory(certs) {
            const categoryPriority = {
                'Identification': 1,
                'Travel Documents': 2,
                'Medical': 3,
                'Survival': 4
            };
            
            const categorized = certs.map(cert => {
                const category = cert.category || 'Other';
                let priority = categoryPriority[category];
                
                if (priority === undefined) {
                    priority = 100 + (category.toLowerCase().charCodeAt(0) - 97);
                }
                
                return {
                    ...cert,
                    priority,
                    sortKey: `${String(priority).padStart(5, '0')}_${category.toLowerCase()}_${cert.name.toLowerCase()}`
                };
            });
            
            categorized.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
            
            return categorized;
        }
        
        function findPersonMatch(name, hrPersonnel) {
            if (hrPersonnel[name]) return hrPersonnel[name];
            
            const searchName = name.toLowerCase().trim();
            const cleanSearchName = searchName.replace(/"[^"]*"/g, '').replace(/\s+/g, ' ').trim();
            const searchParts = cleanSearchName.split(' ').filter(p => p.length > 2);
            
            let bestMatch = null;
            let bestScore = 0;
            
            for (const [hrName, person] of Object.entries(hrPersonnel)) {
                const hrNameLower = hrName.toLowerCase();
                const cleanHRName = hrNameLower.replace(/"[^"]*"/g, '').replace(/\s+/g, ' ').trim();
                
                if (cleanHRName === cleanSearchName) {
                    return person;
                }
                
                const surnameLower = person.surname.toLowerCase();
                if (surnameLower.length > 2 && searchName.includes(surnameLower)) {
                    const firstNameLower = person.firstName.toLowerCase();
                    if (firstNameLower.length > 2 && searchName.includes(firstNameLower)) {
                        return person;
                    }
                }
                
                let score = 0;
                const hrParts = cleanHRName.split(' ').filter(p => p.length > 2);
                
                for (const searchPart of searchParts) {
                    for (const hrPart of hrParts) {
                        if (searchPart === hrPart) score += 2;
                        else if (searchPart.includes(hrPart) || hrPart.includes(searchPart)) score += 1;
                    }
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = person;
                }
            }
            
            if (bestScore >= 2) {
                return bestMatch;
            }
            
            return null;
        }
        
        function createExcelFile(finalMatrix) {
            const projectName = document.getElementById('projectName').value || 'Project';
            const projectYear = document.getElementById('projectYear').value || '2025';
            const projectDesc = document.getElementById('projectDescription').value || '';
            
            const wb = XLSX.utils.book_new();
            const matrixRows = [];
            
            matrixRows.push(['', '', `${projectName} - Crew Matrix`, '', '', '', '', '', '', '', '', '', '']);
            matrixRows.push(['', '', `${projectYear} ${projectDesc}`, '', '', '', '', '', '', '', '', '', '']);
            matrixRows.push(['', '', '', '', '', '', '', '', '', '', '', '', '']);
            //matrixRows.push(['', '', new Date().getTime(), '', '', '', '', '', '', '', '', '', '']);
            
            //const categoryRow = ['', '', '', '', '', '', '', '', '', '', ''];
            
            //finalMatrix.certColumns.forEach((cert) => {
            //    const certType = getCertificationType(cert.name, cert.category);
                
            //    categoryRow.push(cert.category);
            //    categoryRow.push('');
            //    categoryRow.push('');
                
            //    if (certType !== 'medical') {
            //        categoryRow.push('');
            //    }
            //});
            //matrixRows.push(categoryRow);
            
            const headerRow = [
                'No', 'Position', 'Name', 'Nationality', 'DOB', 'Age', 'Gender',
                'Work Mobile', 'Work Email', 'Home Airport', 'Team'
            ];
            
            finalMatrix.certColumns.forEach(cert => {
                const certType = getCertificationType(cert.name, cert.category);
                
                if (certType === 'identification') {
                    headerRow.push(`${cert.name} No.`);
                    headerRow.push(`${cert.name} Issue Date`);
                    headerRow.push(`${cert.name} Expiry Date`);
                } else if (certType === 'medical') {
                    headerRow.push(cert.name);
                    headerRow.push(`${cert.name} Issue Date`);
                    headerRow.push(`${cert.name} Expiry Date`);
                } else {
                    headerRow.push(cert.name);
                    headerRow.push(`${cert.name} Issue Date`);
                    headerRow.push(`${cert.name} Expiry Date`);
                    headerRow.push(`${cert.name} Cert No.`);
                }
            });
            matrixRows.push(headerRow);
            
            finalMatrix.personnel.forEach(person => {
                const row = [
                    person.no,
                    person.occupation,
                    person.name,
                    person.nationality,
                    person.dob || '',
                    person.age,
                    person.gender,
                    person.workMobile,
                    person.email,
                    person.homeAirport,
                    person.team
                ];
                
                finalMatrix.certColumns.forEach(certCol => {
                    const cert = person.certifications[certCol.name];
                    const certType = getCertificationType(certCol.name, certCol.category);
                    
                    if (cert) {
                        if (certType === 'identification') {
                            row.push(cert.reference || '');
                            row.push(cert.validFrom || '');
                            row.push(cert.validTo || '');
                        } else if (certType === 'medical') {
                            row.push(cert.isValid ? '‚úì' : '');
                            row.push(cert.validFrom || '');
                            row.push(cert.validTo || '');
                        } else {
                            row.push(cert.isValid ? '‚úì' : '');
                            row.push(cert.validFrom || '');
                            row.push(cert.validTo || '');
                            row.push(cert.reference || '');
                        }
                    } else {
                        if (certType === 'identification' || certType === 'medical') {
                            row.push('', '', '');
                        } else {
                            row.push('', '', '', '');
                        }
                    }
                });
                
                matrixRows.push(row);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(matrixRows);
            
			const range = XLSX.utils.decode_range(ws['!ref']);
            
            // Find the header row by looking for a row that contains "Name" and "Nationality"
            let headerRowIndex = -1;
            for (let R = 0; R <= Math.min(10, range.e.r); R++) {
                const nameCell = ws[XLSX.utils.encode_cell({r: R, c: 2})]; // Column C typically has "Name"
                const natCell = ws[XLSX.utils.encode_cell({r: R, c: 3})]; // Column D typically has "Nationality"
                
                if (nameCell && natCell && 
                    String(nameCell.v).toLowerCase().includes('name') &&
                    String(natCell.v).toLowerCase().includes('nationality')) {
                    headerRowIndex = R;
                    break;
                }
            }
            
            // Fallback to row 4 if not found
            if (headerRowIndex === -1) {
                headerRowIndex = 4;
            }
            
            // Build a map of column index to header text for quick lookup
            const columnHeaders = {};
            for (let C = 0; C <= range.e.c; C++) {
                const headerCell = ws[XLSX.utils.encode_cell({r: headerRowIndex, c: C})];
                if (headerCell && headerCell.v) {
                    columnHeaders[C] = String(headerCell.v).toLowerCase();
                }
            }
            
            // Format all data rows
            for (let R = headerRowIndex + 1; R <= range.e.r; R++) {
                for (let C = 0; C <= range.e.c; C++) {
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    const cell = ws[cellAddress];
                    
                    if (!cell || cell.v === '' || cell.v == null) continue;
                    
                    const headerText = columnHeaders[C];
                    if (!headerText) continue;
                    
                    // Format any column with "date" or "dob" in the header
                    if ((headerText.includes('date') || headerText.includes('dob')) && 
                        typeof cell.v === 'number' && cell.v > 0) {
                        cell.t = 'n';
                        cell.z = 'dd/mm/yyyy';
                    }
                    
                    // Ensure certificate numbers and passport numbers are treated as text
                    if ((headerText.includes('no.') || headerText.includes('cert no')) && cell.v) {
                        cell.t = 's';
                        cell.v = String(cell.v);
                    }
                }
            }
            
            const colWidths = [
                {wch: 5}, {wch: 25}, {wch: 25}, {wch: 12}, {wch: 12},
                {wch: 6}, {wch: 8}, {wch: 15}, {wch: 25}, {wch: 15}, {wch: 12}
            ];
            
            finalMatrix.certColumns.forEach(cert => {
                const certType = getCertificationType(cert.name, cert.category);
                colWidths.push({wch: 18});
                colWidths.push({wch: 12});
                colWidths.push({wch: 12});
                if (certType !== 'medical') {
                    colWidths.push({wch: 20});
                }
            });
            
            ws['!cols'] = colWidths;
            
            if (!ws['!merges']) ws['!merges'] = [];
            ws['!merges'].push({s:{r:0,c:2}, e:{r:0,c:10}});
            ws['!merges'].push({s:{r:1,c:2}, e:{r:1,c:10}});
            
            XLSX.utils.book_append_sheet(wb, ws, `${projectName} Matrix`);
            return wb;
        }
        
        function getCertificationType(certName, category) {
            const nameLower = certName.toLowerCase();
            const catLower = category.toLowerCase();
            
            if (nameLower.includes('passport') || 
                nameLower.includes('seaman') || 
                nameLower.includes('identification') ||
                catLower.includes('travel') ||
                catLower.includes('identification')) {
                return 'identification';
            }
            
            if (nameLower.includes('medical') || 
                catLower.includes('medical')) {
                return 'medical';
            }
            
            if (nameLower.includes('bosiet') ||
                nameLower.includes('foet') ||
                nameLower.includes('huet') ||
                nameLower.includes('survival') ||
                nameLower.includes('ca-ebs') ||
                nameLower.includes('opito') ||
                catLower.includes('survival')) {
                return 'survival';
            }
            
            return 'certification';
        }
        
        function calculateAge(dob) {
            if (!dob) return '';
            
            let birthDate;
            if (typeof dob === 'number') {
                const utc_days = Math.floor(dob - 25569);
                birthDate = new Date(utc_days * 86400 * 1000);
            } else {
                birthDate = new Date(dob);
            }
            
            const today = new Date();
            let age = today.getFullYear() - birthDate.getFullYear();
            const monthDiff = today.getMonth() - birthDate.getMonth();
            
            if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
                age--;
            }
            
            return age;
        }
        
        function s2ab(s) {
            const buf = new ArrayBuffer(s.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xFF;
            return buf;
        }
    </script>
</body>
</html>